# ADR 004: Using the Truffle Frame for the WebAssembly operand stack and locals

## Context

WebAssembly is implemented as a stack-machine model.
Thus, WebAssembly uses an operand stack that is manipulated by nearly all of its instructions.
In addition, WebAssembly defines local variables to preserve values through several instructions.
This is necessary since WebAssembly does not allow the duplication of values on the operand stack.
This decision is inherited from the original intent of WebAssembly being a subset of JavaScript.

WebAssembly currently defines four value types.
Two integer value types and two floating point value types available as 32-bit and 64-bit versions.
They can be mapped to the `int`, `long`, `float`, and `double` types in Java.

WebAssembly is statically typed.
This means that the value types of local variables and operand stack values are known at parse time and do not require dynamic type checks at run time.

GraalWasm is based on the Truffle language implementation framework and should use all functionality provided by this framework.
Custom implementations should only be used when justified by special requirements.

Truffle provides the `Frame` interface for storing local variables of a guest language (in our case GraalWasm).
The `Frame` is similar to a collection in that it uses individual slots for every local variable and can be accessed via `get` and `set` methods.
The `Frame` performs a dynamic type check when accessing a slot, stores primitive values in a `long` array, and is escape analyzed during partial evaluation.
The slots of the `Frame` are defined via a `FrameDescriptor`. The `FrameDescriptor` is stored in the root node of an AST and is used to initialize the `Frame` slots. The `FrameDescriptor` can be updated in the interpreter to add additional `Frame` slots.

## Decision

We will implement the operand stack values and local variables with the help of the `Frame` regardless of the performed dynamic type checks. These type checks are optimized away during partial evaluation and are only performed in the interpreter. Using a custom data structure might negatively effect the performance of compiled code.

To avoid the dynamic allocation of `Frame` slots during run time, the maximum number of values on the operand stack will be determined during parsing of the WebAssembly bytecode. The number of local variables is also defined for every function in the WebAssembly bytecode. This allows to pre-allocate the `Frame` slots when initializing the root node of a WebAssembly function.

## Status

Deprecated

## Consequences

Using the `Frame` to store the operand stack and the local variables simplifies their representation and reduces the effort for maintaining a custom data structure.
In addition, the `Frame` is specifically optimized for the performance of compiled code. 

However, the `Frame` might be slower in the interpreter due to the overhead introduced by dynamic type checks which are not necessary in GraalWasm.
Furthermore, changes to the `Frame` interface might influence the GraalWasm implementation and have to be monitored.

## Commit

`179a300ef29`

## Artifacts

- [org.graalvm.wasm.nodes.WasmBlockNode](../../src/org.graalvm.wasm/src/org/graalvm/wasm/nodes/WasmBlockNode.java)
- [org.graalvm.wasm.nodes.WasmIfNode](../../src/org.graalvm.wasm/src/org/graalvm/wasm/nodes/WasmIfNode.java)
- [org.graalvm.wasm.nodes.WasmNodeInterface](../../src/org.graalvm.wasm/src/org/graalvm/wasm/nodes/WasmNodeInterface.java)
- [org.graalvm.wasm.nodes.WasmRootNode](../../src/org.graalvm.wasm/src/org/graalvm/wasm/nodes/WasmRootNode.java)
- [org.graalvm.wasm.BinaryParser](../../src/org.graalvm.wasm/src/org/graalvm/wasm/BinaryParser.java)
- [org.graalvm.wasm.ExecutionState](../../src/org.graalvm.wasm/src/org/graalvm/wasm/ExecutionState.java)


## Relations

- is deprecated by [ADR 010](./adr-010.md)